version: 2
reference:
  environment: &ENVIRONMENT
    SLACK_TITLE: Vagrant CI
    RELEASE_TARGET_REPONAME: vagrant-installers
  images:
    ruby23: &ruby23
      docker:
        - image: circleci/ruby:2.3
    ruby24: &ruby24
      docker:
        - image: circleci/ruby:2.4
    ruby25: &ruby25
      docker:
        - image: circleci/ruby:2.5
    ruby26: &ruby26
      docker:
        - image: circleci/ruby:2.6
    builder: &builder
      environment:
        <<: *ENVIRONMENT
      docker:
        - image: $BUILDER_IMAGE
          auth:
            username: $BUILDER_USERNAME
            password: $BUILDER_PASSWORD
  workflows:
    public: &PUBLIC_WORKFLOW
      filters:
        branches:
          only: /^pull\/.*/
    public_master: &PUBLIC_MASTER_WORKFLOW
      filters:
        branches:
          only: master
    private_master: &PRIVATE_MASTER_WORKFLOW
      context: vagrant
      filters:
        branches:
          only: master
    private_build: &PRIVATE_WORKFLOW_BUILD
      context: vagrant
      filters:
        branches:
          only:
            - /^build-.*/
        tags:
          only: /.*/
  jobs:
    private_failure: &PRIVATE_FAILURE
      run:
        name: Failure handler
        command: |
          if [ -f .output ]; then
            slack -m "Vagrant job has failed: *${CIRCLE_JOB}*" -s error -f .output -T 5
          else
            slack -m "Vagrant job has failed: *${CIRCLE_JOB}*" -s error
          fi
        when: on_fail
    unit_tests: &unit_tests
      steps:
        - run: sudo apt-get update ; sudo apt-get -yq install bsdtar
        - checkout
        - restore_cache:
            key: static-site-gems-v1-{{ checksum "Gemfile.lock" }}
        - run:
            command: bundle check || bundle install --path vendor/bundle
        - save_cache:
            key: static-site-gems-v1-{{ checksum "Gemfile.lock" }}
            paths:
              - ./vendor/bundle
        - run: bundle exec rake test:unit
jobs:
  build:
    <<: *builder
    steps:
      - checkout
      - run: gem build vagrant.gemspec
      - *PRIVATE_FAILURE
      - persist_to_workspace:
          root: .
          paths:
            - ./*.gem
  store:
    <<: *builder
    steps:
      - attach_workspace:
          at: .
      - run: |
          gem_name=(vagrant-*.gem)
          if [ "${CIRCLE_TAG}" == "" ]; then
            remote_gem_name="vagrant-master.gem"
          else
            remote_gem_name="vagrant.gem"
          fi
          if [[ "${CIRCLE_BRANCH}" = "build-"* ]]; then
            s3_dst="${ASSETS_PRIVATE_LONGTERM}/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/${CIRCLE_BRANCH##build-}/"
          else
            s3_dst="${ASSETS_PRIVATE_BUCKET}/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/"
          fi
          aws s3 cp "${gem_name}" "${s3_dst}${remote_gem_name}" > .output 2>&1
      - *PRIVATE_FAILURE
  release:
    <<: *builder
    steps:
      - checkout
      - attach_workspace:
          at: .
      - run: |
          set +e
          gem=(vagrant-*.gem)
          gem_version="${gem##vagrant-}"
          gem_version="${gem_version%%.gem}"
          export GITHUB_TOKEN="${HASHIBOT_TOKEN}"
          if [ "${CIRCLE_TAG}" = "" ]; then
            version="v${gem_version}+$(git rev-parse --short "${CIRCLE_SHA1}")"
            ghr -u ${CIRCLE_PROJECT_USERNAME} -r ${RELEASE_TARGET_REPONAME} -c master -prerelease -delete -replace ${version} ${gem} > .output 2>&1
          else
            version="${CIRCLE_TAG}"
            ghr -u ${CIRCLE_PROJECT_USERNAME} -r ${RELEASE_TARGET_REPONAME} -c master -delete -replace ${version} ${gem} > .output 2>&1
          fi
          slack -m "New Vagrant installers release triggered: *${version}*"
      - *PRIVATE_FAILURE
  trigger_release:
    <<: *builder
    steps:
      - checkout
      - run:
          name: Check for version bump
          command: |
            set +e
            compare_url="${CIRCLE_COMPARE_URL/github.com/api.github.com/repos}"
            files=($(curl -SsL -H "Accept: application/json" "${compare_url}" | jq -r .files[].filename))
            for i in "${files[@]}"; do
              if [ "${i}" != "version.txt" ]; then
                continue
              fi
              version=$(<./version.txt)
              if [[ ! "${version}" =~ ^[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+$ ]]; then
                continue
              fi
              tags=($(git tag))
              for j in "${tag[@]}"; do
                if [ "${j}" = "v${version}" ]; then
                  echo "Tag already exists. Exiting..."
                  exit 0
                fi
              done
              echo "Tag for version v${version} does not exist. Trigger release..."
              touch .do-release
              exit 0
            done
      - run:
          name: Setup GitHub User
          command: |
            set +e
            test -f .do-release || exit 0
            git config --local user.email "hashicorp-ci@users.noreply.github.com" && git config --local user.name "hashicorp-ci"
            if [ $? -ne 0 ]; then
              slack -s error -m "Failed to configure GitHub user for release trigger"
              exit 1
            fi
      - run:
          name: Configure GitHub Repository
          command: |
            set +e
            test -f .do-release || exit 0
            git remote add upstream "https://${HASHIBOT_TOKEN}@github.com/hashicorp/vagrant.git"
            if [ $? -ne 0 ]; then
              slack -s error -m "Failed to configure git repository for release trigger"
              exit 1
            fi
      - run:
          name: Update CHANGELOG and Release
          command: |
            set +e
            test -f .do-release || exit 0
            version=$(<./version.txt)
            reldate=$(date +"%B %e %Y")
            sed -i "s/Next version (Unreleased)/${version} (${reldate})/" CHANGELOG.md
            if [ $? -ne 0 ]; then
              slack -s error -m "Failed to update CHANGELOG for release trigger"
              exit 1
            fi
            git commit CHANGELOG.md -m "Update CHANGELOG for release v${version}" && git tag "v${version}"
            if [ $? -ne 0 ]; then
              slack -s error -m "Failed to stage CHANGELOG update for release trigger"
              exit 1
            fi
            echo -e "## Next version (Unreleased)\n\nFEATURES:\n\nIMPROVEMENTS:\n\nBUG FIXES:\n" | cat - CHANGELOG.md > .t && mv .t CHANGELOG.md
            if [ $? -ne 0 ]; then
              slack -s error -m "Failed to write update to CHANGELOG for development"
              exit 1
            fi
            dev_version=$(ruby -e "puts Gem::Version.new(Gem::Version.new(${version}).segments.tap{|x|x[2]=x[2].succ}.join('.'))")
            echo "${dev_version}.dev" > version.txt
            git commit CHANGELOG.md version.txt -m "Update version and CHANGELOG for development v${dev_version}.dev"
            git push upstream master "v${version}"
            if [ $? -ne 0 ]; then
              slack -s error -m "Failed to push updates to GitHub for release trigger"
              exit 1
            fi
            slack -s warn -m "New release has been triggered for version v${version}!"
            exit
  test_ruby23:
    <<: *ruby23
    <<: *unit_tests
  test_ruby24:
    <<: *ruby24
    <<: *unit_tests
  test_ruby25:
    <<: *ruby25
    <<: *unit_tests
  test_ruby26:
    <<: *ruby26
    <<: *unit_tests
  build-website:
    # setting the working_directory along with the checkout path allows us to not have
    # to cd into the website/ directory for commands
    working_directory: ~/project/website
    docker:
      - image: hashicorp/middleman-hashicorp:0.3.35
    steps:
      - checkout:
          path: ~/project
      - restore_cache:
          key: static-site-gems-v1-{{ checksum "Gemfile.lock" }}
      - run:
          command: bundle check || bundle install --path vendor/bundle
      - save_cache:
          key: static-site-gems-v1-{{ checksum "Gemfile.lock" }}
          paths:
            - ~/project/website/vendor/bundle
      - run:
          command: bundle exec middleman build
      - run:
          command: ./scripts/deploy.sh
workflows:
  version: 2
  builds:
    jobs:
      - build:
          <<: *PRIVATE_WORKFLOW_BUILD
      - store:
          <<: *PRIVATE_WORKFLOW_BUILD
          requires:
            - build
      - release:
          <<: *PRIVATE_WORKFLOW_BUILD
          requires:
            - build
  pull_requests:
    jobs:
      - test_ruby23:
          <<: *PUBLIC_WORKFLOW
      - test_ruby24:
          <<: *PUBLIC_WORKFLOW
      - test_ruby25:
          <<: *PUBLIC_WORKFLOW
      - test_ruby26:
          <<: *PUBLIC_WORKFLOW
  master:
    jobs:
      - test_ruby23:
          <<: *PUBLIC_MASTER_WORKFLOW
      - test_ruby24:
          <<: *PUBLIC_MASTER_WORKFLOW
      - test_ruby25:
          <<: *PUBLIC_MASTER_WORKFLOW
      - test_ruby26:
          <<: *PUBLIC_MASTER_WORKFLOW
      - build:
          <<: *PUBLIC_MASTER_WORKFLOW
          context: vagrant
          requires:
            - test_ruby23
            - test_ruby24
            - test_ruby25
            - test_ruby26
      - store:
          <<: *PRIVATE_MASTER_WORKFLOW
          requires:
            - build
      - trigger_release:
          <<: *PRIVATE_MASTER_WORKFLOW
          requires:
            - build
  website:
    jobs:
      - build-website:
          context: static-sites
          filters:
            branches:
              only: stable-website
